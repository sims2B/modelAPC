#include "Problem.h"
#include <random>
#include <limits>
#include <cassert>
Problem::Problem(int nbTask, int nbFam): N(nbTask), M(0){
  F.reserve(nbFam);
  famOf.resize(nbTask);
}

Problem::Problem(int nbTask, int nbMach, int nbFam): N(nbTask), M(nbMach){
  Family _F(M);
  F.resize(nbFam,_F);
  famOf.resize(nbTask);
}

Problem::Problem(int nbTask, int nbMach, std::vector<int> _famOf,
		 familyList _F): N(nbTask), M(nbMach), famOf(_famOf), F(_F){}


int Problem::computeHorizon() const{
  int res=0;
  for (int i = 0 ; i < N ; ++i)
    res+= getDuration(i) + getSetup(i);
  return res;
}




std::string Problem::toString() const{
  std::string res = "Le problème possède les caractéristiques suivantes:\n - le nombre de tâches est :" + std::to_string(N) + "\n - le nombre de machine est :" + std::to_string(M) + "\n - \n";
  for (int i = 0 ; i < N ; ++i)
    res += "  * la tâche " + std::to_string(i) + " appartient à la famille " + std::to_string(famOf[i]) + "\n";
  res+= "- Et les familles (" + std::to_string(F.size()) + ") possèdent les caractéristiques suivantes:\n";
    for (uint f = 0 ; f < F.size() ; ++f)
      res+= "   * " + std::to_string(f) + ": " + F[f].toString();
  return res;
}

int Problem::getNf(int f) const{
  int res = 0;
  for (int i = 0 ; i < N ; ++i)
    if (famOf[i]==f)
      res++;
  return res;
}

Problem generate(int n, int m, int F, int pmax, int sumQualif){
   assert( sumQualif  >= m && sumQualif >= F); 
  Problem P(n,m,F);
  int f;

  
  //random settings
  std::random_device rd;
  std::mt19937 generator(rd());
  std::normal_distribution<> disDur(4*pmax/5,pmax/5);
  int sample;

  //families generation
  //duration
  int minDur = std::numeric_limits<int>::max();
  int maxDur = std::numeric_limits<int>::min();
  for (f = 0 ; f < F ; ++f){
       do {
      sample = (int)disDur(generator);
    } while (sample < 1 || sample > pmax);
    if (sample + P.F[f].setup > maxDur) maxDur = sample + P.F[f].setup;
    if (sample < minDur) minDur = sample;
    P.F[f].duration = sample;
  }

  //setup (TODO !!!! ont tendance a etre tous egaux... :((( )
  std::normal_distribution<> disSet(minDur/2 ,minDur/6);
  for (f = 0 ; f < F ; ++f){
    do {
      sample = (int)disSet(generator);
    } while (sample < 1 || sample > minDur);
    P.F[f].setup = sample;
  }
    //threshold
  std::normal_distribution<> disThres((n+m)*maxDur/(2*m) ,(n-m)*maxDur/(6*m) );
  for (f = 0 ; f < F ; ++f){
    do {
      sample = (int)disThres(generator);
     } while (sample < maxDur || sample > n*maxDur/m);
    P.F[f].threshold = sample;
  }

  //eligibility
  //at the beginning we make sure each machine is selected at least once
  int j = m; f = 0; int nbRes = sumQualif;
  std::normal_distribution<> disNbMach(sumQualif/F , sumQualif / (3*F));
  std::uniform_int_distribution<> machQualif(0,m-1);
  std::vector<int> selected(m,0);
  
  while (j > 0 && f < F){
    //number of qualified machine for a family
    if (f < F-1){
      do {
	sample = (int)disNbMach(generator);
      } while (sample < 1 || sample > nbRes - (F - f - 1));
    }
    else sample = nbRes;
    nbRes = nbRes - sample;
    //machine affectation
    do {
      int index =  machQualif(generator)%j;
      int select = -1;
      while (index > -1 ){
	if (!selected[select+1])
	  index--;
	select++;
      } 
      selected[select] = 1;
      P.F[f].qualif[select] = 1;
      j--; sample--;
    } while (sample > 0 && j > 0);
    if (j > 0) f++;  
    else {
       while (sample > 0){
	int select = machQualif(generator) % m;
	if (P.F[f].qualif[select] != 1){
	  P.F[f].qualif[select] = 1;
	  sample--;
	} 
      } 
    }
  }
  
  //rest of the families qualification
   for (int rest = f + 1 ; rest < F ; ++rest){
    j = m;
      if (rest < F-1){
      do {
	sample = (int)disNbMach(generator);
      } while (sample < 1 || sample > nbRes - (F - rest - 1));
    }
    else sample = nbRes;
    nbRes = nbRes - sample;
    while (sample > 0){
      int index =  machQualif(generator)%j;
      int select = -1;
      while (index > -1 ){
	if (!P.F[rest].qualif[select+1])
	  index--;
	select++;
      } 
      P.F[rest].qualif[select] = 1;
      j--; sample--;
    }
  }

   //problem generation (family affectation)
  nbRes = n;
  std::normal_distribution<> disNf(n/F , n/(F*3));
  std::uniform_int_distribution<int> famAffect(0,n);
  selected.clear();  selected.resize(n,0);
  for (f = 0 ; f < F ; ++f){
    if (f < F-1)
      do {
	sample = (int)disNf(generator);
      } while (sample < 1 || sample > nbRes - ( F - f - 1) );
    else sample = nbRes;
    while (sample > 0){
      int index = famAffect(generator) % nbRes;
      int select = -1;
      while (index > -1){
	if (!selected[select+1])
	  index--;
	select++;
      }
      selected[select] = 1;
      P.famOf[select] = f;
      sample--; nbRes--;
    }
  }
  
  
  
  return P;
}
